export function checkReentrancy(sourceCode: string): string[] {
    let vulnerabilities: string[] = [];
  
    // Step 1: Look for external calls that can cause reentrancy issues
    // Potential problems is for example if state is changed before .call() is executed tha contract should not have this error message
    const externalCallRegex = /(\.call\b|\.delegatecall\b|\.send\b|call\.value)\s*({[^}]*})?\s*\(/;
    let hasExternalCall = externalCallRegex.test(sourceCode);
    console.log("Has external call:", hasExternalCall);
  
    // Step 2: Check if the nonReentrant modifier is present
    let hasNonReentrant = sourceCode.includes('nonReentrant');
    console.log("Has nonReentrant modifier:", hasNonReentrant);
  
    // Step 3: Detect internal state changes before external calls
    // Broad pattern to detect updates to balances or other state variables
    const stateUpdateRegex = /(balances\[.*\]\s*(\+|-|=)\s*\w+)/;
    let stateUpdateBeforeCall = stateUpdateRegex.test(sourceCode);
    console.log("Has state update before call:", stateUpdateBeforeCall);
  
    // Step 4: Flag contracts only if they have an external call without protection and no state update before the call
    if (hasExternalCall && !hasNonReentrant && !stateUpdateBeforeCall) {
      vulnerabilities.push(
        'Warning: Detected external call without a nonReentrant modifier or state update before the call. This could lead to reentrancy vulnerabilities.'
      );
    } else {
      console.log('No reentrancy issues detected');
    }
  
    return vulnerabilities;
  }


// TEST SMART CONTRACT

// // SPDX-License-Identifier: MIT
// pragma solidity ^0.8.0;

// contract VulnerableContract {
//     mapping(address => uint256) public balances;

//     function deposit() public payable {
//         balances[msg.sender] += msg.value;
//     }

//     // Vulnerable withdraw function
//     function withdraw(uint256 _amount) public {
//         require(balances[msg.sender] >= _amount, "Insufficient balance");

//         // External call to send Ether (vulnerability)
//         (bool success, ) = msg.sender.call{value: _amount}("");  
//         require(success, "Transfer failed");

//         // State is updated AFTER the call, which opens up a reentrancy vulnerability
//         balances[msg.sender] -= _amount;
//     }

//     function getContractBalance() public view returns (uint256) {
//         return address(this).balance;
//     }
// }
